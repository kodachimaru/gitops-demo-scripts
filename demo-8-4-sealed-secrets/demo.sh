
# Install SealedSecrets controller
SS_RELEASE="0.7.0"
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v${SS_RELEASE}/sealedsecret-crd.yaml
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v${SS_RELEASE}/controller.yaml



# Install Flux

helm init

helm repo add fluxcd https://charts.fluxcd.io

# We configure Flux to do garbage collection
# Also, we don't need the HelmOperator for this example
helm install \
    --name flux \
    --set git.url=git@github.com:kodachimaru/gitops-demo-flux-4-sealed-secrets.git \
    --set git.branch=staging \
    --set git.pollInterval=5s \
    --set syncGarbageCollection.enabled=true \
    --namespace flux \
    fluxcd/flux

# Get autogenerated SSH key
#Â Add it to GitHub repo, read/write access (more on this later)
fluxctl identity --k8s-fwd-ns=flux



# Monitor Flux workloads
watch "echo ------------- HELM LIST ; helm list --all ; echo -------------- STAGING RES LIST ; kubectl get all -n staging ; echo ------------- FLUX WORKLOAD LIST ; fluxctl --k8s-fwd-ns flux list-workloads -n staging"
# Watch Flux installing the resources
while true; do kubectl logs -f $(kubectl get pods -n flux -o name | grep flux | grep -v helm | grep -v memcached) -n flux ; done
# Show the secret content being correctly accessed  
while true; do kubectl logs -n staging -f $(k get pods -n staging -o name | grep busybox) ; done



# Clone repo
git clone https://github.com/kodachimaru/gitops-demo-flux-4-sealed-secrets.git
cd gitops-demo-flux-4-sealed-secrets

# Create target branch staging from master
git checkout master
git checkout -b staging
# Push the Kube resources, including the cleartext secrets, to Git
git push --set-upstream origin staging

# Wait for Flux to publish the staging branch to Kube
# Pod works fine because the Secret is there, but it's in cleartext on git
kubectl get secrets -n staging
# See the logs for the busybox-deployment pod
#   "The secret text is: THIS_IS_MY_SECRET_CONTENT"
kubectl logs -n staging -f $(k get pods -n staging -o name | grep busybox)



# Playing with garbage collection

# Delete the target branch
# This won't delete the busybox-deployment, even with garbage collection enabled
# Note:
#   - By default Flux doesn't remove Kube resources when they disappear from Git
#       It needs to be explicitly configured to do so ("garbage collection")
#       Reason: To be able to use Flux in places with already running resources without interference
#       If starting from scratch, it's good to enable auto delete
git checkout master
git branch -D staging
git push origin --delete staging

# Restart Flux by scaling up & down its Deployment
kubectl scale deployment flux -n flux --replicas=0
kubectl scale deployment flux -n flux --replicas=1
# No need to redeploy the Flux SSH key again, it's cached to persist across pod restarts
fluxctl identity --k8s-fwd-ns=flux
# However this doesn't delete the existing busybox-deployment either
# Seems garbage collection doesn't run when the git branch disappears

# Let's try creating an empty staging branch
git checkout master
git checkout -b staging
rm *
git push --set-upstream origin staging
# This time Flux deletes the resources

# Let's delete the experimental staging branch
git checkout master
git branch -D staging
git push origin --delete staging



# We will now replace the cleartext secret with a SealedSecret
# Let's create again the staging branch
git checkout master
git checkout -b staging
git push --set-upstream origin staging
# The busybox-deployment is deployed again with the cleartext secret
kubectl logs -n staging -f $(k get pods -n staging -o name | grep busybox)
    # "The secret text is: THIS_IS_MY_SECRET_CONTENT"

# Recreate the-secret as a SealedSecret
# https://engineering.bitnami.com/articles/sealed-secrets.html
kubectl create secret generic the-secret \
    --from-literal=secret-file.txt=THIS_IS_MY_SEALED_SECRET_CONTENT \
    --type=string \
    -o json -n staging --dry-run \
    | kubeseal --format yaml > the-secret.sealedsecret.yaml
cat the-secret.sealedsecret.yaml

# Remove the old secret
rm the-secret.secret.yaml

# Commit and push the new SealedSecret
git add . 
git commit -m "Switched Secret by SealedSecret"
git push --set-upstream origin staging
    # The SealedSecret is published, detected by the SS Operator and converted to a standard Secret.
    # The busybox-deployment is not recreated, but it picks the new Secret automatically.
    # Why? Because it's accessing the Secret as a mounted volume, which is one of the cases where 
    # this can be done by hot swapping.

# Show the secret content being correctly accessed  
kubectl logs -n staging -f $(k get pods -n staging -o name | grep busybox)
    # "The secret text is: THIS_IS_MY_SEALED_SECRET_CONTENT"



# Undo

git checkout master
git branch -D staging
git push origin --delete staging

cd ..
rm -rf gitops-demo-flux-4-sealed-secrets

helm delete --purge flux
kubectl delete namespace flux

kubectl delete -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v${SS_RELEASE}/sealedsecret-crd.yaml
kubectl delete -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v${SS_RELEASE}/controller.yaml

kubectl delete namespace staging

helm reset

helm repo remove fluxcd
